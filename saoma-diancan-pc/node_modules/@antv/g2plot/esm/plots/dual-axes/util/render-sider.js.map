{"version":3,"file":"render-sider.js","sourceRoot":"","sources":["../../../../src/plots/dual-axes/util/render-sider.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,IAAI,EAAE,WAAW,EAAE,MAAM,YAAY,CAAC;AAC/C,OAAO,EAAE,SAAS,EAAE,MAAM,gBAAgB,CAAC;AAE3C;;;;;;GAMG;AACH,MAAM,CAAC,IAAM,cAAc,GAAG,UAAC,IAAU,EAAE,WAA6B;IAC/D,IAAA,GAAG,GAAS,WAAW,GAApB,EAAE,GAAG,GAAI,WAAW,GAAf,CAAgB;IAC/B,IAAM,IAAI,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC,IAAI,CAAC;IACpC,IAAM,MAAM,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;IAChC,IAAM,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC;IAC5B,IAAI,CAAC,MAAM,IAAI,CAAC,QAAQ,EAAE;QACxB,OAAO;KACR;IACD,IAAM,YAAY,GAAG,IAAI,CAAC;IAC1B,IAAM,MAAM,GAAG,WAAW,CAAC,IAAI,EAAE,MAAM,CAAC,KAAK,CAAC,CAAC;IAC/C,IAAM,OAAO,GAAG,YAAY,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,OAAO,EAAE,CAAC;IACzD,IAAM,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC;IACjC,IAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC,CAAC;IACpD,IAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC,CAAC;IAEpD,aAAa;IACb,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,EAAE,UAAC,KAAU;QACnC,IAAM,GAAG,GAAW,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;QAC3C,OAAO,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,GAAG,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;IAC9D,CAAC,CAAC,CAAC;IACH,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;AACpB,CAAC,CAAC","sourcesContent":["import { View } from '@antv/g2';\nimport { size, valuesOfKey } from '@antv/util';\nimport { isBetween } from '../../../utils';\n\n/**\n * 右侧 View 进行 slider 过滤\n * 由于双轴图是多 View , 需要监听左侧 Slider 的 change 事件来同步右侧 View\n * @param { View } view 右侧视图\n * @param { number[] } sliderValue 滑块当前值\n * @returns void\n */\nexport const doSliderFilter = (view: View, sliderValue: [number, number]) => {\n  const [min, max] = sliderValue;\n  const data = view.getOptions().data;\n  const xScale = view.getXScale();\n  const dataSize = size(data);\n  if (!xScale || !dataSize) {\n    return;\n  }\n  const isHorizontal = true;\n  const values = valuesOfKey(data, xScale.field);\n  const xValues = isHorizontal ? values : values.reverse();\n  const xTickCount = size(xValues);\n  const minIndex = Math.floor(min * (xTickCount - 1));\n  const maxIndex = Math.floor(max * (xTickCount - 1));\n\n  // 增加 x 轴的过滤器\n  view.filter(xScale.field, (value: any) => {\n    const idx: number = xValues.indexOf(value);\n    return idx > -1 ? isBetween(idx, minIndex, maxIndex) : true;\n  });\n  view.render(true);\n};\n"]}