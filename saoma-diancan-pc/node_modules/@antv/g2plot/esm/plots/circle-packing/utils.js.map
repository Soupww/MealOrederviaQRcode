{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../../src/plots/circle-packing/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import { Types } from '@antv/g2';\nimport { pack } from '../../utils/hierarchy/pack';\nimport { deepAssign, pick } from '../../utils';\nimport { HIERARCHY_DATA_TRANSFORM_PARAMS } from '../../interactions/actions/drill-down';\nimport { normalPadding } from '../../utils/padding';\nimport { CirclePackingOptions } from './types';\n\ninterface TransformDataOptions {\n  data: CirclePackingOptions['data'];\n  rawFields: CirclePackingOptions['rawFields'];\n  enableDrillDown: boolean;\n  hierarchyConfig: CirclePackingOptions['hierarchyConfig'];\n}\n\n/**\n * circle-packing 数据转换\n * @param options\n */\nexport function transformData(options: TransformDataOptions) {\n  const { data, hierarchyConfig, rawFields = [], enableDrillDown } = options;\n\n  const nodes = pack(data, {\n    ...hierarchyConfig,\n    field: 'value',\n    as: ['x', 'y', 'r'],\n  });\n\n  const result = [];\n  nodes.forEach((node) => {\n    let path = node.data.name;\n    let ancestorNode = { ...node };\n    while (ancestorNode.depth > 1) {\n      path = `${ancestorNode.parent.data?.name} / ${path}`;\n      ancestorNode = ancestorNode.parent;\n    }\n\n    // 开启下钻，仅加载 depth <= 2 的数据 (加载两层)\n    if (enableDrillDown && node.depth > 2) {\n      return null;\n    }\n\n    const nodeInfo = deepAssign({}, node.data, {\n      ...pick(node.data, rawFields),\n      path,\n      // 以下字段，必备: x, y, r, name, depth, height\n      ...node,\n    });\n\n    nodeInfo.ext = hierarchyConfig;\n    nodeInfo[HIERARCHY_DATA_TRANSFORM_PARAMS] = { hierarchyConfig, rawFields, enableDrillDown };\n\n    result.push(nodeInfo);\n  });\n\n  return result;\n}\n\n/**\n * 根据图表的 padding 和 appendPadding 计算出图表的最终 padding\n * @param array\n */\nexport function resolveAllPadding(paddings: Types.ViewPadding[]) {\n  // 先把数组里的 padding 全部转换成 normal\n  const normalPaddings = paddings.map((item) => normalPadding(item));\n  let finalPadding = [0, 0, 0, 0];\n  if (normalPaddings.length > 0) {\n    finalPadding = finalPadding.map((item, index) => {\n      // 有几个 padding 数组就遍历几次，累加\n      normalPaddings.forEach((d, i) => {\n        item += normalPaddings[i][index];\n      });\n      return item;\n    });\n  }\n  return finalPadding;\n}\n\n/**\n * 根据传入的 padding 和 现有的 画布大小， 输出针对圆形视图布局需要的 finalPadding 以及 finalSize\n * @param params\n */\nexport function resolvePaddingForCircle(\n  padding: Types.ViewPadding,\n  appendPadding: Types.ViewAppendPadding,\n  containerSize: { width: number; height: number }\n) {\n  const tempPadding = resolveAllPadding([padding, appendPadding]);\n  const [top, right, bottom, left] = tempPadding; // 没设定，默认是 [0, 0, 0, 0]\n  const { width, height } = containerSize;\n\n  // 有了 tempPadding 介入以后，计算出coordinate范围宽高的最小值 minSize = circle-packing的直径\n  const wSize = width - (left + right);\n  const hSize = height - (top + bottom);\n  const minSize = Math.min(wSize, hSize); // circle-packing的直径\n\n  // 得到居中后各方向剩余的 padding\n  const restWidthPadding = (wSize - minSize) / 2;\n  const restHeightPadding = (hSize - minSize) / 2;\n\n  const finalTop = top + restHeightPadding;\n  const finalRight = right + restWidthPadding;\n  const finalBottom = bottom + restHeightPadding;\n  const finalLeft = left + restWidthPadding;\n\n  const finalPadding = [finalTop, finalRight, finalBottom, finalLeft];\n  const finalSize = minSize < 0 ? 0 : minSize; // 防止为负数\n\n  return { finalPadding, finalSize };\n}\n"]}