{"version":3,"file":"pack.js","sourceRoot":"","sources":["../../../src/utils/hierarchy/pack.ts"],"names":[],"mappings":";;;;AAAA,gEAA4C;AAC5C,mCAA6C;AAC7C,+BAA+C;AAK/C,IAAM,eAAe,GAAY;IAC/B,KAAK,EAAE,OAAO;IACd,EAAE,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;IACnB,OAAO;IACP,IAAI,EAAE,UAAC,CAAC,EAAE,CAAC,IAAK,OAAA,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,KAAK,EAAjB,CAAiB;CAClC,CAAC;AAEF,SAAgB,IAAI,CAAC,IAAS,EAAE,OAAgB;IAC9C,OAAO,GAAG,aAAM,CAAC,EAAa,EAAE,eAAe,EAAE,OAAO,CAAC,CAAC;IAC1D,IAAM,EAAE,GAAG,OAAO,CAAC,EAAE,CAAC;IACtB,IAAI,CAAC,cAAO,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC,MAAM,KAAK,CAAC,EAAE;QACnC,MAAM,IAAI,SAAS,CAAC,0EAA0E,CAAC,CAAC;KACjG;IAED,IAAI,KAAK,CAAC;IACV,IAAI;QACF,KAAK,GAAG,eAAQ,CAAC,OAAO,CAAC,CAAC;KAC3B;IAAC,OAAO,CAAC,EAAE;QACV,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;KACjB;IAED,IAAM,UAAU,GAAG,UAAC,IAAI;QACtB,OAAA,WAAW,CAAC,IAAI,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,CAC5D,WAAW;aACR,SAAS,CAAC,IAAI,CAAC;aACf,GAAG,CAAC,UAAC,CAAC,IAAK,OAAA,CAAC,CAAC,KAAK,CAAC,EAAR,CAAQ,CAAC;aACpB,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CACtB;IALD,CAKC,CAAC;IAEJ,IAAM,IAAI,GAAG,UAAU,CAAC,IAAI,CAAC,CAAC;IAE9B,IAAM,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;IAChB,IAAM,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;IAChB,IAAM,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;IAChB,IAAI,CAAC,IAAI,CAAC,UAAC,IAAI;QACb,IAAI,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC;QACjB,IAAI,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC;QACjB,IAAI,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC;IACnB,CAAC,CAAC,CAAC;IAEH,OAAO,kBAAW,CAAC,IAAI,CAAC,CAAC;AAC3B,CAAC;AAlCD,oBAkCC","sourcesContent":["import * as d3Hierarchy from 'd3-hierarchy';\nimport { assign, isArray } from '@antv/util';\nimport { getField, getAllNodes } from './util';\nimport { HierarchyOption } from './types';\n\ntype Options = Omit<HierarchyOption, 'as'> & { as?: [string, string, string] };\n\nconst DEFAULT_OPTIONS: Options = {\n  field: 'value',\n  as: ['x', 'y', 'r'],\n  // 默认降序\n  sort: (a, b) => b.value - a.value,\n};\n\nexport function pack(data: any, options: Options): any[] {\n  options = assign({} as Options, DEFAULT_OPTIONS, options);\n  const as = options.as;\n  if (!isArray(as) || as.length !== 3) {\n    throw new TypeError('Invalid as: it must be an array with 3 strings (e.g. [ \"x\", \"y\", \"r\" ])!');\n  }\n\n  let field;\n  try {\n    field = getField(options);\n  } catch (e) {\n    console.warn(e);\n  }\n\n  const packLayout = (data) =>\n    d3Hierarchy.pack().size(options.size).padding(options.padding)(\n      d3Hierarchy\n        .hierarchy(data)\n        .sum((d) => d[field])\n        .sort(options.sort)\n    );\n\n  const root = packLayout(data);\n\n  const x = as[0];\n  const y = as[1];\n  const r = as[2];\n  root.each((node) => {\n    node[x] = node.x;\n    node[y] = node.y;\n    node[r] = node.r;\n  });\n\n  return getAllNodes(root);\n}\n"]}