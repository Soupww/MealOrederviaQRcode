{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../src/geometry/label/util/index.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @file utils of label\n */\n\nimport { isNil, isNumber, some } from '@antv/util';\nimport { IElement, IGroup, BBox } from '../../../dependents';\nimport { rotate } from '../../../util/transform';\nimport { LabelItem } from '../interface';\n\n/**\n * 查找 Label Group 中的文本 shape 对象\n * @param label\n */\nexport function findLabelTextShape(label: IGroup): IElement {\n  return label.find((el) => el.get('type') === 'text');\n}\n\n/**\n * 获取标签背景信息: box (无旋转) + rotation (旋转角度)\n */\nexport function getlLabelBackgroundInfo(\n  labelGroup: IGroup,\n  labelItem: LabelItem,\n  padding: number | number[] = [0, 0, 0, 0]\n): { x: number; y: number; width: number; height: number; rotation: number } {\n  const content = labelGroup.getChildren()[0];\n  if (content) {\n    const labelShape = content.clone();\n\n    // revert rotate\n    if (labelItem?.rotate) {\n      rotate(labelShape as IGroup, -labelItem.rotate);\n    }\n\n    // use `getCanvasBBox`, because if Shape is been translated, `getBBox` is not the actual box position\n    const { x, y, width, height } = labelShape.getCanvasBBox();\n\n    labelShape.destroy();\n\n    let boxPadding = padding;\n    if (isNil(boxPadding)) {\n      boxPadding = [2, 2, 2, 2];\n    } else if (isNumber(boxPadding)) {\n      boxPadding = new Array(4).fill(boxPadding);\n    }\n\n    return {\n      x: x - boxPadding[3],\n      y: y - boxPadding[0],\n      width: width + boxPadding[1] + boxPadding[3],\n      height: height + boxPadding[0] + boxPadding[2],\n      rotation: labelItem?.rotate || 0,\n    };\n  }\n}\n\n/**\n * 计算两个矩形之间的堆叠区域面积\n */\nexport function getOverlapArea(a: BBox, b: BBox, margin = 0) {\n  const xOverlap = Math.max(\n    0,\n    Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin)\n  );\n  const yOverlap = Math.max(\n    0,\n    Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin)\n  );\n\n  return xOverlap * yOverlap;\n}\n\n/** 检测是否和已布局的堆叠 */\nexport function checkShapeOverlap(cur: IElement, dones: IElement[]) {\n  const box = cur.getBBox();\n  return some(dones, (done) => {\n    const target = done.getBBox();\n    return getOverlapArea(box, target, 2) > 0;\n  });\n}\n"]}